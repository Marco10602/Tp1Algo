\documentclass[10pt,a4paper]{article}

\input{AEDmacros}
\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex


\titulo{Trabajo Práctico 1: Especificación y WP}
\subtitulo{"En Búsqueda del Camino"}

\fecha{\today}

\materia{Algoritmos y Estructuras de Datos}
\grupo{Grupo puntoJava}

\integrante{Gremes, Juan Ignacio}{21/24}{juanigremes@gmail.com}
\integrante{Anllo, Francisco}{209/24}{anllo.francisco@gmail.com}
\integrante{Naddeo, Matias}{651/24}{email3@dominio.com}
\integrante{Gutierrez, Marco}{167/24}{marcoantonio-gutierrez02@hotmail.com}

% Declaramos donde van a estar las figuras
% No es obligatorio, pero suele ser comodo
\graphicspath{{../static/}}

\begin{document}

\maketitle
%------------------------------- Empieza la seccion especificacion
\section{Especificación}


%                                            EJERCICIO 1.1
\subsection{grandesCiudades:}

A partir de una lista de ciudades, devuelve aquellas que tienen más de 50.000 habitantes.\\

\begin{proc}{grandesCiudades}{\In ciudades : \TLista{\str\times\ent}}{\TLista{\str\times\ent}}
	\requiere{True}
	\asegura{\paraTodo[unalinea]{i}{\ent}{(0 \leq i < |res|) \implicaLuego ((res[i] \in ciudades) \yLuego (res[i]_1 > 50.000))}}
	\asegura{\paraTodo[unalinea]{j}{\ent}{((0 \leq j < |ciudades|) \yLuego (ciudades[j]_1 > 50.000)) \implicaLuego (ciudades[j] \in res)}}
\end{proc}


%                                            EJERCICIO 1.2
\subsection{sumaDeHabitantes:}

Por cuestiones de planificación urbana, las ciudades registran sus habitantes mayores de edad por un lado y menores de edad por el otro.

Dadas dos listas de ciudades del mismo largo con los mismos nombres, una con sus habitantes mayores y otra con sus habitantes menores, este procedimiento debe devolver una lista de ciudades con la cantidad total de sus habitantes.\\

\begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades : \TLista{\str\times\ent}, \In mayoresDeCiudades : \TLista{\str\times\ent}}{\TLista{\str\times\ent}}
	\requiere{|menoresDeCiudades| = |mayoresDeCiudades|}
	\requiere{\paraTodo[unalinea]{i}{\ent}{(0 \leq i < |menoresDeCiudades|) \implicaLuego (\#Apariciones(menoresDeCiudades[i]_0 , menoresDeCiudades) = \#Apariciones(menoresDeCiudades[i]_0 , mayoresDeCiudades))}}
	\asegura{|res| = |menoresDeCiudades|}
	\asegura{\paraTodo[unalinea]{j}{\ent}{(0 \leq j < |res|) \implicaLuego (\#Apariciones(res[j]_0 , res) = \#Apariciones(res[j]_0 , menoresDeCiudades))}}
	\asegura{\paraTodo[unalinea]{x,y,z}{\ent}{((0 \leq x < |res|) \land (0 \leq y < |res|) \land (0 \leq z < |res|) \yLuego (menoresDeCiudades[x]_0 = mayoresDeCiudades[y]_0 = res[z]_0)) \implicaLuego (res[z]_1 = menoresDeCiudades[x]_1 + mayoresDeCiudades[y]_1 )}}
\end{proc}

\aux{\#Apariciones}{ciudad : \str , ciudades : \TLista{\str\times\ent}}{\ent}{\sum\limits_{k=0}^{|ciudades| - 1} IfThenElse(ciudad = ciudades[k]_0, 1, 0)}


%                                            EJERCICIO 1.3
\subsection{hayCamino:}

Un mapa de ciudades está conformada por ciudades y caminos que unen a algunas de ellas.
A partir de este mapa, podemos definir las distancias entre ciudades como una matriz donde cada celda i, j representa la distancia entre la ciudad i y la ciudad j. Una distancia de 0 equivale a no haber camino entre i y j.
Notar que la distancia de una ciudad hacia sí misma es cero y la distancia entre A y B es la misma que entre B y A.

Dadas dos ciudades y una matriz de distancias, se pide determinar si existe un camino entre ambas ciudades.\\

\begin{proc}{hayCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde : \ent, \In hasta : \ent}{\bool}
	\requiere{0\leq desde,hasta<|distancias| \land {\paraTodo[unalinea]{i,j}{\ent}{0\leq i,j < |distancias| \implicaLuego (|distancias|=|distancias[i]| \yLuego 0\leq distancias[i][j])}}}
	\asegura{res = True \Leftrightarrow {\existe[unalinea]{s}{\TLista{\ent}}{esCamino(distancias, desde, hasta, s)}}}
\end{proc}

\pred{hayCaminoDirecto}{c1 : \ent, c2 : \ent, distancias : \TLista{\TLista{\ent}}}{distancias[c1][c2] \neq 0}

\pred{esCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde : \ent, \In hasta: \ent, \In camino:\TLista{\ent}}{|camino|>1 \yLuego camino[0]= desde \land camino[|camino|-1]=hasta \land 0\leq hasta<|camino|\land (\paraTodo[unalinea]{i}{\ent}{0\leq i<|res|-1 \implicaLuego (0\leq camino[i]<|distancias| \yLuego hayCaminoDirecto(camino[i],camino[i+1],distancias)))}}

\aux{distancia}{\In distancias : \TLista{\TLista{\ent}},  \In camino:\TLista{\ent}}{\ent}{
\begin{equation}
\sum\limits_{k=0}^{|s|-2} distancias[camino[k]][camino[k+1]]\label{eq:1}
\end{equation}} 


%                                            EJERCICIO 1.4
\subsection{cantidadCaminosNSaltos:}

Dentro del contexto de redes informáticas, nos interesa contar la cantidad de “saltos” que realizan los paquetes de datos, donde un salto se define como pasar por un nodo.
Así como definimos la matriz de distancias, podemos definir la matriz de conexión entre nodos, donde cada celda i, j tiene un 1 si hay un único camino a un salto de distancia entre el nodo i y el nodo j, y un 0 en caso contrario.
En este caso, se trata de una matriz de conexión de orden 1, ya que indica cuáles pares de nodos poseen 1 camino entre ellos a 1 salto de distancia.

Dada la matriz de conexión de orden 1, este procedimineto debe obtener aquella de orden n que indica cuántos caminos de n saltos hay entre los distintos nodos.
Notar que la multiplicación de una matriz de conexión de orden 1 consigo misma nos da la matriz de conexión de orden 2, y así sucesivamente.


%                                            EJERCICIO 1.5
\subsection{caminoMínimo}
Dada una matriz de distancias, una ciudad de origen y una ciudad de destino, este procedimiento debe devolver la lista de ciudades que conforman el camino más corto entre ambas.
En caso de no existir un camino, se debe devolver una lista vacía.

\begin{proc}{caminoMinimo}{\In distancias : \TLista{\TLista{\ent}}, \In desde : \ent, \In hasta: \ent}{\TLista{\ent}}
    \requiere{0\leq desde,hasta<|distancias| \land {\paraTodo[unalinea]{i,j}{\ent}{0\leq i,j < |distancias| \implicaLuego (|distancias|=|distancias[i]| \yLuego 0\leq distancias[i][j])}}}
	\asegura{res="lista vacia" \Leftrightarrow \lnot  hayCamino(distancias, desde, hasta) \land (hayCamino(distancias, desde, hasta) \implicaLuego (esCamino(distancias, desde, hasta, res) \yLuego \lnot{\existe[unalinea]{s}{\TLista{\ent}}{esCamino(distancia, desde, hasta, s) \yLuego distancia(distancias, s)\leq distancia(distancias, res)}}))}
\end{proc}

%------------------------------------------ CAMBIO DE SECCION : demostraciones de correctidud
\section{Demostraciones de Correctitud}


%                                            EJERCICIO 2.1

La función poblaciónTotal recibe una lista de ciudades donde al menos una de ellas es grande (es decir, supera los 50.000 habitantes) y devuelve la cantidad total de habitantes. Dada la siguiente especificación:

\begin{proc}{poblaciónTotal}{\In ciudades : \TLista{\str\times\ent}}{\ent}
    \requiere{\existe[unalinea]{i}{\ent}{(0 \leq i < |ciudades|) \yLuego (ciudades[i].habitantes > 50.000)} \wedge \\ 
    \paraTodo[unalinea]{i}{\ent}{(0 \leq i < |ciudades|) \implicaLuego (ciudades[i].habitantes \geq 0)} \wedge \\
    \paraTodo[unalinea]{i, j}{\ent} {(0 \leq i < j < |ciudades|) \implicaLuego (ciudades[i].nombre \neq ciudades[j].nombre)}}
    \asegura{res = \sum\limits_{i=0}^{|ciudades| - 1}ciudades[i].habitantes}
\end{proc}
Con la siguiente implementación:\\

res = 0\\
i = 0\\
while ( i $<$ ciudades.length) do\\
res = res + ciudades[i].habitantes\\
i = i + 1\\
endwhile\\

\textbf{1. Demostrar que la implementación es correcta con respecto a la especificación.}\\

Para poder asegurar que la implementación es correcta, debemos probar que se cumple la tripla de Hoare [P] S [Q]. Es decir, P $\implicaLuego$ wp(S,Q). En primer lugar, intentaremos identificar esta precondición P y post condición Q.
La post condición Q es el estado que buscaremos que el programa se encuentre una vez que finalice. De acuerdo a la especificación, es posible concluir que:
\textbf{{Q = ${\sum\limits_{i=0}^{|ciudades| - 1}ciudades[i].habitantes}$}}

Como el programa termina en el ciclo "while", es válido afirmar que la post condición del programa será la misma que la del ciclo. En otras palabras, \textbf{Q = Qc}. Es imperativo, entonces, comprobar la correctitud del ciclo, y para ello utilizaremos el Teorema del Invariante y el Teorema de Terminación.
Veamos, en primer lugar, cuál es la precondición del ciclo. Sabemos que esta será la precondición del programa, más cualquier instrucción hasta llegar al comienzo del ciclo. Entonces, podemos decir que, como P es todas las condiciones establecidas en los \textit{requiere}, entonces Pc lo será también, sumadas las dos instrucciones antes de llegar al ciclo. Por lo tanto, \textbf{Pc = P $\wedge$ i = 0 $\wedge$ res = 0}\\
    Proponemos, entonces, el siguiente invariante: \textbf{I = $0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{j=0}^{i - 1}ciudades[j].habitantes$}. Veamos ahora si cumple las tres condiciones necesarias: \\
    
    1) Pc $\implica$ I: \\
    
        Pc $\implica$ (i = 0 $\wedge$ res = 0) $\implica$ 0 $\leq$ 0 $\leq |ciudades| \wedge  res = \sum\limits_{j=0}^{0 - 1}ciudades[j].habitantes$ \\
        Como la sumatoria se encuentra fuera de rango, el total es igual a 0. Se cumple, entonces, que res = 0. Verificamos que esta condición es verdadera; veamos las otras dos.\\
        
    2) I $\wedge$  $\neg$B $\implica$ Qc  \\
    
    Llamamos B a la guarda del "while". En este caso, la guarda es $ i < ciudades.length$, por lo que la negación de B sería $i \geq |ciudades|$. Ahora que tenemos bien definido todo, veamos si esto se cumple: \\
    I $\wedge$  $\neg$B = ($0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{j=0}^{i - 1}ciudades[j].habitantes \wedge i \geq |ciudades|)$ \\
    Si condensamos estas condiciones, es claro que... \\
    I $\wedge$  $\neg$B $\implica$$ (i = |ciudades| \wedge res = \sum\limits_{j=0}^{i - 1}ciudades[j].habitantes) \implica res = \sum\limits_{j=0}^{|ciudades| - 1}ciudades[j].habitantes$\\
    ¡Que es exactamente lo que establece Qc! Veamos la última condición.\\

    3) [I $\wedge$ B] S [I]\\

    Tengo que probar que {($0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{j=0}^{i - 1}ciudades[j].habitantes \wedge i < |ciudades|)  \implicaLuego$ wp(S,I)} \\Condensado, esto es lo mismo que decir ($0 \leq i < |ciudades| \yLuego res = \sum\limits_{j=0}^{i - 1}ciudades[j].habitantes) \implicaLuego$ wp(S, I)\\
    
        Para esto, llamaremos S1 a la primera instrucción dentro del ciclo, y S2 a la segunda. Por lo tanto, \textbf{S1 = (res = res + ciudades[i].habitantes)} y \textbf{S2 = (i = i + 1)}\\
        
    wp(S, I) = wp(S1, wp(S2, I)) = wp(res = res + ciudades[i].habitantes, wp(S2, I))\\
    
    wp(S2, I) = (i := i + 1, $0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{j=0}^{i - 1}ciudades[j].habitantes$ \\

    Utilizando el Axioma 1 (Asignación), reemplazaremos el valor de \textit{i} en cada una de sus apariciones libres, que en este caso, son todas: \\
    wp(S2, I) = def (i + 1) $\yLuego (0 \leq i+1 \leq |ciudades| \yLuego res = \sum\limits_{j=0}^{i + 1 - 1}ciudades[j].habitantes$)\\
    Como i+1 no trae ninguna restricción, su definición es igual a \textit{True}. Nos queda, entonces...\\
    
    wp(S2, I) = $0 \leq i < |ciudades| \yLuego res = \sum\limits_{j=0}^{i}ciudades[j].habitantes$\\
    
    Retomando con lo anterior, obtenemos que:\\

    wp(S, I) = wp(res = res + ciudades[i].habitantes, $0 \leq i < |ciudades| \yLuego res = \sum\limits_{j=0}^{i}ciudades[j].habitantes$)\\

    Nuevamente, utilizaremos el Axioma 1. La expresion queda de la siguiente manera:\\
    
    def (res) $\yLuego$ def (ciudades[i]) $\yLuego$ res + ciudades[i].habitantes = $\sum\limits_{j=0}^{i}ciudades[j].habitantes$\\

    Como res no tiene restricciones, esa definición es \textit{True }. Sin embargo, ciudades[\textit{i}] requiere que \textit{i} esté en rango de la lista. Por otro lado, podemos decir que $\sum\limits_{j=0}^{i}ciudades[j].habitantes = \sum\limits_{j=0}^{i-1}(ciudades[j].habitantes) + ciudades[i].habitantes$ Veamos cómo sigue:\\

    $0 \leq i < |ciudades| \yLuego (res + ciudades[i].habitantes = \sum\limits_{j=0}^{i-1}(ciudades[j].habitantes) + ciudades[i].habitantes)$ \\
    
    Es decir que wp(S, I) = $0 \leq i < |ciudades| \yLuego res = \sum\limits_{j=0}^{i-1}ciudades[j].habitantes$\\

    Recapitulando...\\

    ($0 \leq i < |ciudades| \yLuego res = \sum\limits_{j=0}^{i - 1}ciudades[j].habitantes) \implicaLuego$ wp(S, I) es verdadero, porque son exactamente el mismo predicado. Por lo tanto, el ciclo es parcialmente correcto. Falta comprobar si siempre termina, que probaremos a través del Teorema de Terminación.\\
    
    Proponemos la Función Variante (fv) = $|ciudades| - i$. Veamos si cumple las condiciones:\\

    1) I $\wedge$ fv $\leq 0  \implica \neg B$\\

    $0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{j=0}^{i - 1}ciudades[j].habitantes \wedge |ciudades| - i \leq 0 \implicaLuego i \geq |ciudades|$ \\
    
    $0 \leq i \leq |ciudades| \yLuego res = \sum\limits_{j=0}^{i - 1}ciudades[j].habitantes \wedge |ciudades| \leq i \implicaLuego i \geq |ciudades|$ \\

    $i = |ciudades| \wedge  res = \sum\limits_{j=0}^{i - 1}ciudades[j].habitantes \implicaLuego i \geq |ciudades|$\\

    Que es verdadero, ya que $i = |ciudades| \implica i \geq ciudades$. Veamos la siguiente condición.\\

    2) [I $\wedge$ B $\wedge$ V0 = fv] S [fv $<$ V0]\\

    $I \yLuego B \yLuego V0 = |ciudades| - i \implica$ wp(S, fv $<$ V0)\\
    
    Usando S, dividido en S1 y S2 como fue explicado anteriormente, podemos decir que:\\
    
    wp(S, fv $<$ V0) = wp(res = res + ciudades[i].habitantes, wp(S2, fv $<$ V0))\\

    wp(S2, fv $<$ V0) = wp(i := i + 1, $|ciudades| - i < V0$) Usando el Axioma 1 obtenemos: $|ciudades| - i - 1 < V0$, ya que (i + 1) ya está definido.\\

    wp(S, fv $<$ V0) = wp(res = res + ciudades[i].habitantes, $|ciudades| - i - 1 < V0$). Usando el axioma 1, obtenemos: $def (s[i]) \yLuego |ciudades| - i - 1 < V0$, porque \textit{res} ya está definido.\\

    ($0\leq i \leq |ciudades| \yLuego |ciudades| - i - 1 < |ciudades| - i) \implica fv < V0$. Se cumple esta condición también, por lo que hemos comprobado, a través del Teorema del Invariante y del Teorema de Terminación, que el ciclo es correcto y siempre termina. Pero como hay dos instrucciones antes de que comience el ciclo, no hemos terminado. Veamos que, a través de esas dos instrucciones -que llamaremos T1 y T2, y T a su conjunto-, se cumple la tripla de Hoare [P] T [Pc]. \\

    ¿P $\implicaLuego$ wp(T, Pc)? Calculamos wp(T, Pc):\\

    wp(T, Pc) = wp(res := 0, wp(T2, Pc)) = wp(res := 0; i := 0, P $\wedge$ i = 0 $\wedge$ res = 0)\\ 
    Usando dos veces el axioma 1, vemos que i = 0 y res = 0 son dos predicados \textit{True}, y por lo tanto Pc se reduce a:\\ (P $\wedge$ True $\wedge$ True). Entonces wp(T, Pc) = P, y es una tautología decir que P $\implica$ P.\\

    Queda demostrado, entonces, que la implementación es correcta con respecto de la especificación.\\
    
%                                            EJERCICIO 2.2

2. \textbf{Demostrar que el valor devuelto es mayor a 50.000.}\\

Ya hemos probado que la implementación es correcta de acuerdo a la especificación. Es decir que P $\implica$ wp(S, Q), siendo Q: res = $\sum\limits_{i=0}^{|ciudades| - 1}ciudades[i].habitantes$. Ahora, queremos demostrar que, dada cualquier lista que cumpla P, res $>$ 50.000.
Sabemos que $\existe[unalinea]{i}{\ent}{(0 \leq i < |ciudades|) \yLuego (ciudades[i].habitantes > 50.000)}$, por lo que analizaremos distintos casos de la lista \textit{ciudades} teniendo esto en cuenta:\\

$|ciudades| = 0 \implica \neg \existe[unalinea]{i}{\ent}{(0 \leq i < 0) \yLuego (ciudades[i].habitantes > 50.000)}$. Por lo tanto, $|ciudades| > 0$\\

$|ciudades| = 1 \implica \existe[unalinea]{i}{\ent}{(0 \leq i < 1) \yLuego (ciudades[i].habitantes > 50.000)}$. Como la lista tiene solo 1 elemento, ese elemento tiene que ser mayor a 50.000, por lo que el resultado también lo será.\\

$|ciudades| > 1:$ llamaremos \textbf{K} a la posición particular donde el valor sea mayor a 50.000, que sabemos que tiene que existir, ya que así lo establece P. Podemos decir entonces...\\

res = $\sum\limits_{i=0}^{k - 1}(ciudades[i].habitantes) + ciudades[k].habitantes + \sum\limits_{i=k+1}^{|ciudades| - 1}(ciudades[i].habitantes)$\\
Notemos que esta igualdad es verdadera, ya que resulta de separar el valor original de res en distintas series con índices diferentes. Sabemos que, por lo que establecimos anteriormente, que ciudades[k].habitantes $>$ 50.000. Basta entonces con probar que ambas sumatorias son igual o mayores a 0 para que res $>$ 50.000.\\

$k \neq 0 \wedge k \neq (|ciudades| - 1) \implica 0 \leq k - 1 < k + 1 \leq |ciudades| - 1$. \\

Es decir, ambas sumatorias están en el rango de la lista. La precondición P también nos dice que...\\

$\paraTodo[unalinea]{i}{\ent}{(0 \leq i < |ciudades|) \implicaLuego (ciudades[i].habitantes \geq 0)}$\\

Para toda posición dentro de la lista, se cumple que su valor es igual o mayor a 0. Como vimos que ambas sumatorias están, efectivamente, en rango de la lista, entonces cada uno de sus términos valdrá, como mínimo, 0, ¡que era la conclusión a la que queríamos llegar! Nótese lo siguiente:\\

$k = 0 \implica res = \sum\limits_{i=0}^{-1}(ciudades[i].habitantes) + ciudades[0].habitantes + \sum\limits_{i=1}^{|ciudades| - 1}(ciudades[i].habitantes)$ \\

La primera sumatoria, como sus índices están fuera de rango, es igual a 0. Ciudades[0].habitantes $>$ 50.000, y la otra serie será igual o mayor a 0, por lo demostrado anteriormente. La variable \textit{res} será, entonces, mayor a 50.000. Lo mismo sucede si k = $|ciduades| - 1$, solo que en ese caso, será la segunda sumatoria, cuyo índice inferior es (k + 1), la que se encontrará fuera de rango, pero el razonamiento es el mismo.\\

Probamos, entonces, que dada cualquier lista que cumpla la especificación, como la implementación del programa es correcta, res $>$ 50.000.

\newpage % ************** PASE TODO LO QUE YA ESTABA A OTRA PAGINA ASI NO ME MOLESTA ************** % 



\subsection{esto ya estaba}

Lo principal: las fórmulas. Se puede poner en una linea, como $x_i = x_{i-1} + x_{i-2}$, o ponerse más grande:

\begin{equation}
	\sum\limits_{i=0}^{n} i
	\label{eq:1}
\end{equation}

Y se pueden citar ecuaciones con \verb|\eqref{nombreDeEq}|: \eqref{eq:1}

Ejemplo de itemizado:

\begin{itemize}
	\item Item 1
	\item Item 2
	\item Item 3
\end{itemize}

Ejemplo de enumerado con menor distancia entre items:

\begin{enumerate} \setlength\itemsep{0cm}
	\item Item 1
	\item Item 2
	\item Item 3
\end{enumerate}

Podemos escribir mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto.

Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo.

\vspace{0.3cm}

Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos.

\vspace{0.3cm}

La tabla \ref{tab:ejemplo} es un ejemplo de cómo se hace una tabla.

\begin{table}[h!]
	\centering
	\begin{tabular}{||l c c r||} 
		\hline
		Col1 & Col2 & Col2 & Col3 \\ [0.5ex] 
		\hline\hline
		1 & 6 & 87837 & 787 \\ 
		2 & 7 & 78 & 5415 \\
		3 & 545 & 778 & 7507 \\
		4 & 545 & 18744 & 7560 \\
		5 & 88 & 788 & 6344 \\
		\hline
	\end{tabular}
	\caption{Ejemplo de tabla}
	\label{tab:ejemplo}
\end{table}


La figura \ref{fig:subfigs} es un ejemplo de cómo se agrega una imagen.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{logo_dc.jpg}
	\caption{Ejemplo de figura}
	\label{fig:ejemplo}
\end{figure}

\begin{figure}[ht!]
	\begin{subfigure}{0.5\textwidth}
		\includegraphics[width=0.5\linewidth]{LaTeX-project} 
		\caption{Logo de LaTeX}
		\label{fig:subfig1}
	\end{subfigure}
	\begin{subfigure}{0.8\textwidth}
		\includegraphics[width=0.2\linewidth]{TeX}
		\caption{Logo de TeX}
		\label{fig:subfig2}
	\end{subfigure}
	\caption{Ejemplo para poner dos figuras juntas. Y citarlas por separado a (\subref{fig:subfig1}) y (\subref{fig:subfig2}).}
	% OJO: el caption siempre va antes del label
	\label{fig:subfigs}
\end{figure}



% Para hacer que quede todo en una misma linea, se puede usar minipage
%\begin{minipage}[t]{\textwidth}
	\begin{lstlisting}[caption={Ejemplo de código (usando los estilos de la cátedra, ver las macros para más detalles)},label=code:for]
res := 0;
i := 0;
while (i < s.size()) do
	res := res + s[i];
	i := i + 1
endwhile
	\end{lstlisting}
%\end{minipage}

Si se pone un label al \verb|lstlisting|, se puede referenciar: Código \ref{code:for}.


\subsection{Macros de la cátedra para especificar}

\begin{proc}{nombre}{\In paramIn : \nat, \Inout paramInout : \TLista{\ent}}{tipoRes}
	%    \modifica{parametro1, parametro2,..}
	\requiere{expresionBooleana1}
	\asegura{expresionBooleana2}
	\aux{auxiliar1}{parametros}{tipoRes}{expresion}
	\pred{pred1}{parametros}{expresion} 
\end{proc}

\aux{auxiliarSuelto}{parametros}{tipoRes}{expresion}
% \paraTodo{variable}{tipo}{expresion}
% \existe{variable}{tipo}{expresion}
% Pueden tener [unalinea] para que no se divida en varias lineas
\pred{predSuelto}{parametros}{\paraTodo[unalinea]{variable}{tipo}{algo \implicaLuego expresion}}
\pred{predSuelto}{parametros}{\existe[unalinea]{variable}{tipo}{algo \yLuego expresion}}



\end{document}
